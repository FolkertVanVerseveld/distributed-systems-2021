# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/154tmQwFV51pLTCwRojACo2SbSDufYkNP


This script contains all collected data from crash_test by varying its parameters.
Two plots are generated to show the effiency and average recovery time.
"""

import matplotlib.pyplot as plt
import numpy as np

def get_efficiency(up, stored, count):
  """Compute efficiency and ensure up and stored were computed correctly."""
  #d = np.diff(up)
  #d_up = np.concatenate(([up[0]], d))
  #d = np.diff(stored)
  #d_stored = np.concatenate(([stored[0]], d))
  if sum(up) < count:
    print(f'bad up: {up}')
  if sum(stored) != count:
    print(f'bad stored: {stored}, total: {sum(stored)}')

  wasted = up - stored
  efficiency = count / (count + sum(wasted))
  return efficiency, wasted

def get_stats(rec, up, stored, count):
  """Determine efficiency and average recovery time."""
  efficiency, wasted = get_efficiency(up, stored, count)

  avg_rec = float(sum(rec) / rec.shape)
  return wasted, efficiency, avg_rec

def print_stats(rec, up, stored, count):
  efficiency, wasted = get_efficiency(up, stored, count)
  print(f'wasted: {wasted}, total: {sum(wasted)}')
  #avg_eff = float(sum(efficiency) / efficiency.shape)
  print(f'average efficiency: {efficiency * 100.0:.2f}%')

  avg_rec = float(sum(rec) / rec.shape)
  print(f'average recovery: {avg_rec:.2f} sec')


############
# Datasets #
############

up5 = np.array([2, 1, 2])
stored5 = np.array([2, 1, 2])
rec5 = np.array([0.508963443338871, 0.652291645295918, 0.5705487160012126])
count5 = 5

#sum(up) == count
print_stats(rec5, up5, stored5, count5)

up10     = np.array([3 - 0 + 1, 2, 5 - 3 + 1, 6 - 5 + 1, 7 - 6 + 1, 10 - 7])
stored10 = np.array([2 - 0 + 1, 0, 3 - 2 + 1, 6 - 5 + 1, 0, 10 - 7])
rec10 = np.array([0.4903015801683068, 0.6115178968757391, 0.567168059758842, 0.6307159010320902, 0.5591116258874536, 0.624748163856566])
count10 = 10

print_stats(rec10, up10, stored10, count10)

up25     = np.array([4 - 0 + 1, 7 - 3 + 1, 10 - 8 + 1, 13 - 9 + 1, 16 - 12 + 1, 19 - 15 + 1, 22 - 18 + 1, 25 - 21])
stored25 = np.array([2 - 0 + 1, 7 - 3 + 1, 8 - 8 + 1,  11 - 9 + 1, 14 - 12 + 1, 17 - 15 + 1, 20 - 18 + 1, 25 - 21])
rec25 = np.array([0.5107753602787852, 0.5423169312998652, 0.5441998327150941, 0.5610046917572618, 0.5521501814946532, 0.5697891898453236, 0.5487613622099161])
count25 = 25

print_stats(rec25, up25, stored25, count25)

up50     = np.array([10 - 0 + 1, 20 - 11 + 1, 26 - 17 + 1, 32 - 23 + 1, 38 - 29 + 1, 45 - 35 + 1, 50 - 41])
stored50 = np.array([10 - 0 + 1, 16 - 11 + 1, 22 - 17 + 1, 28 - 23 + 1, 34 - 29 + 1, 40 - 35 + 1, 50 - 41])
rec50 = np.array([0.5188131518661976, 0.6156755490228534, 0.5606368789449334, 0.5632894625887275, 0.5531263034790754, 0.5298235472291708, 0.5543902181088924])
count50 = 50

print_stats(rec50, up50, stored50, count50)

up100     = np.array([20 - 0 + 1, 31 - 11 + 1, 43 - 22 + 1, 53 - 33 + 1, 64 - 44 + 1, 75 - 55 + 1, 86 - 66 + 1, 97 - 77 + 1, 100 - 88])
stored100 = np.array([10 - 0 + 1, 21 - 11 + 1, 32 - 22 + 1, 43 - 33 + 1, 54 - 44 + 1, 65 - 55 + 1, 76 - 66 + 1, 87 - 77 + 1, 100 - 88])
rec100 = np.array([0.5466411346569657, 0.5942075299099088, 0.549306508153677, 0.5615127151831985, 0.537374016828835, 0.5506737967953086, 0.5616647452116013, 0.5381173808127642, 0.5515747154131532])
count100 = 100

print_stats(rec100, up100, stored100, count100)

up200     = np.array([44 - 0 + 1, 84 - 44 + 1, 108 - 66 + 1, 130 - 88 + 1, 152 - 110 + 1, 174 - 132 + 1, 196 - 154 + 1, 200 - 176])
stored200 = np.array([44 - 0 + 1, 65 - 45 + 1, 87 - 66 + 1, 109 - 88 + 1, 131 - 110 + 1, 153 - 132 + 1, 175 - 154 + 1, 200 - 176])
rec200 = np.array([0.4734098566696048, 0.6509442320093513, 0.5431293630972505, 0.5381470732390881, 0.5818163612857461, 0.5576431546360254, 0.5308166583999991, 0.5358892604708672])
count200 = 200

print_stats(rec200, up200, stored200, count200)

up500 = np.array([216 - 0 + 1, 322 - 115 + 1, 445 - 231 + 1, 500 - 346])
stored500 = np.array([115 - 0 + 1, 231 - 115 + 1, 346 - 231 + 1, 500 - 346])
rec500 = np.array([0.5031326347962022, 0.5842382861301303, 0.5377165852114558, 0.5522904293611646])
count500 = 500

print_stats(rec500, up500, stored500, count500)

# Process data for plots
wasted, efficiency, avg_rec = [], [], []
rec = [rec5, rec10, rec25, rec50, rec100, rec200, rec500]
up = [up5, up10, up25, up50, up100, up200, up500]
stored = [stored5, stored10, stored25, stored50, stored100, stored200, stored500]
count = [5, 10, 25, 50, 100, 200, 500]

min_rec = []
max_rec = []
std_rec = []

for i in range(len(count)):
  w, e, a = get_stats(rec[i], up[i], stored[i], count[i])
  wasted += [w]
  efficiency += [e]
  avg_rec += [a]
  min_rec += [min(rec[i])]
  max_rec += [max(rec[i])]
  std_rec += [np.array(rec[i]).std]

def plot(x, count, ylabel, title, name):
  """Give plot for specified data with label and save settings."""
  x = np.arange(len(count))

  plt.clf()
  plt.plot(x, np.array(efficiency))

  plt.xticks(x, [str(v) for v in count])
  plt.xlabel('kv pair count')
  plt.ylabel(ylabel)
  plt.title(title)

  plt.savefig(f'{name}.pdf')
  plt.show()

  try:
    from google.colab import files
    files.download(f'{name}.pdf')
  except Exception as e:
    print(f'probably not running in colab mode: {e}')

plot(efficiency, count, 'efficiency (%)', 'Fault-tolerance efficiency for varying KV pair count', 'efficiency')

# manually rolled out of plot() due to min/max and stdev visualisation
plt.clf()
fig, ax = plt.subplots()
x = np.arange(len(count))
ax.fill_between(x, np.array(min_rec), np.array(max_rec), alpha=0.5, linewidth=0)
#ax.plot(x, np.array(avg_rec))
ax.errorbar(x, np.array(avg_rec), np.std(avg_rec))
plt.xticks(x, [str(v) for v in count])
plt.xlabel('kv pair count')
plt.ylabel('average recovery time (sec)')
plt.title('Fault-tolerance average recovery time for varying KV pair count')

plt.savefig('avg_recovery.pdf')
plt.show()

try:
  from google.colab import files
  files.download('avg_recovery.pdf')
except Exception as e:
  print(f'probably not running in colab mode: {e}')

